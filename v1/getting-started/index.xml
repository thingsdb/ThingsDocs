<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Getting started on ThingsDB documentation</title><link>https://docs.thingsdb.net/v1/getting-started/</link><description>Recent content in Getting started on ThingsDB documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://docs.thingsdb.net/v1/getting-started/index.xml" rel="self" type="application/rss+xml"/><item><title>Build from source</title><link>https://docs.thingsdb.net/v1/getting-started/build-from-source/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.thingsdb.net/v1/getting-started/build-from-source/</guid><description>First, install the following required dependencies:
libuv1 libpcre2 libyajl libcurl When using Debian/Ubuntu; libuv1, libpcre2, libyajl and libcurl can be installed using apt:
sudo apt-get install -y \ libuv1-dev \ libpcre2-dev \ libyajl-dev \ libcurl4-nss-dev \ Next, clone the ThingsDB project.
git clone https://github.com/thingsdb/ThingsDB.git Then compile the source code to make it executable.
cd ThingsDB/Release make clean &amp;amp;&amp;amp; make Finally, you might want to create a symlink like this:</description></item><item><title>Docker</title><link>https://docs.thingsdb.net/v1/getting-started/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.thingsdb.net/v1/getting-started/docker/</guid><description>Images Docker images of ThingsDB are available at GitHub.
Supported tags:
ghcr.io/thingsdb/node:VERSION (Minimal ThingsDB image based on Alpine Linux.)
ghcr.io/thingsdb/node:gcloud-VERSION (Includes Google Cloud Utilities so ThingsDB can created backups in the Google Cloud.)
ghcr.io/thingsdb/node:full-VERSION (Based on a Debian image with Google Cloud Utilities, Python3 and py-timod installed.)
ghcr.io/thingsdb/node:latest (Latest ThingsDB build from the master branch using a minimal Alpine Linux base image)
Getting started The basic steps required to run the ThingsDB server in Docker are explained below.</description></item><item><title>Configuration</title><link>https://docs.thingsdb.net/v1/getting-started/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.thingsdb.net/v1/getting-started/configuration/</guid><description>ThingsDB can start with a configuration file and/or with environment variables. However be aware that the environment variables will overwrite the configuration file settings if both apply to the same setting.
Variable Default Description THINGSDB_BIND_CLIENT_ADDR 127.0.0.1 Bind client connections to this address. This variable both allows an IPv4 address like 0.0.0.0 or IPv6 like ::. THINGSDB_BIND_NODE_ADDR 127.0.0.1 Bind node connections to this address.</description></item><item><title>Start up node</title><link>https://docs.thingsdb.net/v1/getting-started/start-up-node/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.thingsdb.net/v1/getting-started/start-up-node/</guid><description>ThingsDB can work with a single node but is designed to work with at least two nodes but three nodes are preferred. Running on three nodes brings redundancy and ensures the database stays operational, even while you for example upgrade ThingsDB to a newer version.
After building the source code and making a symlink, you can start your first node using the following command. You need to add the --init flag to initialize a new ThingsDB store.</description></item><item><title>Readiness and liveness</title><link>https://docs.thingsdb.net/v1/getting-started/readiness-liveness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.thingsdb.net/v1/getting-started/readiness-liveness/</guid><description>When http_status_port is set in the configuration file or the environment variable THINGSDB_HTTP_STATUS_PORT then /status, /ready and /healthy are available. These can be used for readiness and liveness requests.
Liveness The ThingsDB /healthy check will respond with a 200 OK whenever possible and will never respond with an error. So only if no response is received in some reasonable amount of time, the node should be considered as unhealthy. It is common to use the /healthy check as liveness probe in environments like Kubernetes.</description></item></channel></rss>